// functions/src/quiz/quizzes.ts

import { onCall, HttpsError } from "firebase-functions/v2/https";
import { db } from "../firebaseAdmin";
import { now } from "../quiz/utils/time";
import type {
  CreateQuizInput,
  QuizQuestion,
  Quiz,
  Participant,
  LeaderboardEntry,
  QuizType, // "org-async" | "personal-async"
} from "./quiz";

/* -------------------------------- helpers -------------------------------- */

async function assertMember(orgId: string | undefined, uid?: string) {
  if (!uid) throw new HttpsError("unauthenticated", "Login required");
  if (!orgId) throw new HttpsError("invalid-argument", "Missing orgId");
  const member = await db.ref(`organizations/${orgId}/members/${uid}`).get();
  if (!member.exists()) throw new HttpsError("permission-denied", "Not a member");
}

/** normalize LLM output to our QuizQuestion shape + basic validation */
function normalizeQuestions(qs: any[]): QuizQuestion[] {
  if (!Array.isArray(qs) || qs.length === 0) {
    throw new HttpsError("invalid-argument", "questions array is required and must be non-empty");
  }

  const cleaned: QuizQuestion[] = qs.map((q, i) => {
    const question = String(q?.question ?? "").trim();
    const rawOpts = Array.isArray(q?.options) ? q.options : [];
    const options = rawOpts.slice(0, 4).map((o: any) => String(o ?? "").trim());
    if (options.length !== 4 || options.some((o: string) => !o)) {
      throw new HttpsError("invalid-argument", `question ${i} must have exactly 4 non-empty options`);
    }

    let correct =
      typeof q?.correctIndex === "number"
        ? q.correctIndex
        : typeof q?.answerIndex === "number"
        ? q.answerIndex
        : -1;

    if (!(correct >= 0 && correct < 4)) {
      throw new HttpsError("invalid-argument", `question ${i} has invalid answer index`);
    }

    return {
      id: String(i),
      question,
      options,
      correctIndex: correct,
      explanation: typeof q?.explanation === "string" ? q.explanation.trim() : "",
    };
  });

  return cleaned;
}

function computeAttemptStats(ans: any[]): { avgTimeMs: number; correctCount: number } {
  const times = ans.map((a) => a?.timeMs).filter((x: any) => typeof x === "number");
  const avgTimeMs = times.length ? Math.round(times.reduce((a: number, b: number) => a + b, 0) / times.length) : 0;
  const correctCount = ans.filter((a) => a?.correct).length;
  return { avgTimeMs, correctCount };
}

async function recomputeAndStoreOrgLeaderboard(orgId: string, quizId: string, uidJustFinishedOrUpdated: string) {
  const quizSnap = await db.ref(`organizations/${orgId}/quizzes/${quizId}`).get();
  const q = quizSnap.val() as Quiz;
  const me = q?.participants?.[uidJustFinishedOrUpdated];

  // If user does not exist in participants (rare), just rebuild from existing rows
  const ans = me?.answers ? (Object.values(me.answers) as any[]) : [];
  const { avgTimeMs, correctCount } = computeAttemptStats(ans);

  const row: LeaderboardEntry = {
    uid: uidJustFinishedOrUpdated,
    name: me?.displayName ?? uidJustFinishedOrUpdated,
    score: me?.score ?? 0,
    correctCount,
    avgTimeMs,
  };

  // write/update my row even if unfinished
  await db
    .ref(`organizations/${orgId}/orgAsyncResults/${quizId}/${uidJustFinishedOrUpdated}`)
    .set({
      ...row,
      finishedAt: me?.finishedAt ?? null,
      totalQuestions: Object.values(q?.questions || {}).length,
    });

  // rebuild leaderboard (top 50)
  const allResSnap = await db.ref(`organizations/${orgId}/orgAsyncResults/${quizId}`).get();
  const rows = Object.values(allResSnap.val() || {}) as any[];
  rows.sort((a: any, b: any) => b.score - a.score || a.avgTimeMs - b.avgTimeMs);
  await db.ref(`organizations/${orgId}/orgAsyncLeaderboards/${quizId}`).set(rows.slice(0, 50));

  // convenience snapshot on the quiz doc
  await db.ref(`organizations/${orgId}/quizzes/${quizId}/endSummary`).set({
    leaderboard: rows.slice(0, 50),
    // keep finishedAt if the quiz is actually done for a user; otherwise null
    finishedAt: me?.finished ? me?.finishedAt ?? now() : null,
  });
}

/* ------------------------------- CREATE APIs ------------------------------ */

/**
 * Create an ORG anytime quiz from an org note.
 * Client MUST provide `questions` (already generated by LLM on the client).
 * Writes (under org):
 * - organizations/{orgId}/quizzes/{quizId}
 * - organizations/{orgId}/orgAsyncQuizzes/{noteId}/{quizId}
 */
export const createOrgAsyncQuiz = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  const { orgId, noteId, questionDurationSec, questions } =
    req.data as CreateQuizInput & { orgId: string; questions?: any[] };

  await assertMember(orgId, uid);
  if (!noteId) throw new HttpsError("invalid-argument", "Missing noteId");
  if (!Array.isArray(questions) || questions.length === 0)
    throw new HttpsError("invalid-argument", "questions are required (generate on client first)");

  // Ensure note exists (but we do not parse/sanitize here)
  const noteSnap = await db.ref(`organizations/${orgId}/notes/${noteId}`).get();
  if (!noteSnap.exists()) throw new HttpsError("not-found", "Note not found");

  const quizId = db.ref(`organizations/${orgId}/quizzes`).push().key!;
  const finalQuestions = normalizeQuestions(questions);

  const quiz: Quiz = {
    id: quizId,
    orgId,
    noteId,
    creatorId: uid!,
    type: "org-async",
    state: "active",
    createdAt: now(),
    questionDurationSec,
    seed: `${noteId}:${uid}:${now()}`,
    questions: finalQuestions.reduce(
      (acc, q) => ((acc[q.id] = q), acc),
      {} as Record<string, QuizQuestion>
    ),
    participants: {},
  };

  const updates: Record<string, any> = {};
  updates[`organizations/${orgId}/quizzes/${quizId}`] = quiz;
  updates[`organizations/${orgId}/orgAsyncQuizzes/${noteId}/${quizId}`] = {
    id: quizId,
    title: "Anytime Quiz",
    numQuestions: finalQuestions.length,
    questionDurationSec,
    createdAt: quiz.createdAt,
  };

  await db.ref().update(updates);
  return { quizId, type: "org-async" as QuizType };
});

/**
 * Create a SELF (personal-async) quiz from an org or personal note.
 * Client MUST provide `questions` (already generated by LLM on the client).
 * Writes (under user):
 * - users/{uid}/quizzes/{quizId}
 * - userAsyncQuizzes/{uid}/{noteId}/{quizId}
 */
export const createSelfAsyncQuiz = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  if (!uid) throw new HttpsError("unauthenticated", "Login required");

  const { noteId, questionDurationSec, orgId, questions } =
    req.data as CreateQuizInput & { orgId?: string; questions?: any[] };

  if (!noteId) throw new HttpsError("invalid-argument", "Missing noteId");
  if (!Array.isArray(questions) || questions.length === 0)
    throw new HttpsError("invalid-argument", "questions are required (generate on client first)");

  let notePath: string;
  if (orgId) {
    await assertMember(orgId, uid);
    notePath = `organizations/${orgId}/notes/${noteId}`;
  } else {
    notePath = `users/${uid}/notes/${noteId}`;
  }

  // Ensure note exists (but we do not parse/sanitize here)
  const noteSnap = await db.ref(notePath).get();
  if (!noteSnap.exists()) throw new HttpsError("not-found", "Note not found");

  const quizId = db.ref(`users/${uid}/quizzes`).push().key!;
  const finalQuestions = normalizeQuestions(questions);

  const quiz: Quiz = {
    id: quizId,
    type: "personal-async",
    noteId,
    creatorId: uid!,
    state: "active",
    createdAt: now(),
    questionDurationSec,
    seed: `${noteId}:${uid}:${now()}`,
    questions: finalQuestions.reduce(
      (acc, q) => ((acc[q.id] = q), acc),
      {} as Record<string, QuizQuestion>
    ),
    participants: {},
  };

  const updates: Record<string, any> = {};
  updates[`users/${uid}/quizzes/${quizId}`] = quiz;
  updates[`userAsyncQuizzes/${uid}/${noteId}/${quizId}`] = {
    id: quizId,
    title: "Self Quiz",
    numQuestions: finalQuestions.length,
    questionDurationSec,
    createdAt: quiz.createdAt,
  };

  await db.ref().update(updates);
  return { quizId, type: "personal-async" as QuizType };
});

/* ---------------------------------- LIST --------------------------------- */

export const listOrgAsyncQuizzes = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  const { orgId, noteId } = req.data as { orgId: string; noteId: string };
  await assertMember(orgId, uid);

  const snap = await db.ref(`organizations/${orgId}/orgAsyncQuizzes/${noteId}`).get();
  const val = snap.val() || {};
  const items = Object.values(val);
  items.sort((a: any, b: any) => (b.createdAt ?? 0) - (a.createdAt ?? 0));
  return { items };
});

export const listPersonalAsyncQuizzes = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  if (!uid) throw new HttpsError("unauthenticated", "Login required");
  const { noteId } = req.data as { noteId: string };

  const snap = await db.ref(`userAsyncQuizzes/${uid}/${noteId}`).get();
  const val = snap.val() || {};
  const items = Object.values(val);
  items.sort((a: any, b: any) => (b.createdAt ?? 0) - (a.createdAt ?? 0));
  return { items };
});

/* ------------------------------ ORG-ASYNC -------------------------------- */

export const startOrResumeOrgAsyncAttempt = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  const { orgId, quizId, displayName } = req.data as {
    orgId: string;
    quizId: string;
    displayName: string;
  };
  await assertMember(orgId, uid);

  const path = `organizations/${orgId}/quizzes/${quizId}`;
  const snap = await db.ref(path).get();
  if (!snap.exists()) throw new HttpsError("not-found", "Quiz not found");
  const quiz = snap.val() as Quiz;
  if (quiz.type !== "org-async") throw new HttpsError("failed-precondition", "Not an Anytime (org) quiz");

  await db.ref(`${path}/participants/${uid}`).transaction((p: any) => {
    if (!p) {
      const init: Partial<Participant> = {
        joinedAt: now(),
        displayName,
        connected: true,
        score: 0,
        currentIndex: 0,
        questionStartAt: now(),
      };
      return init;
    }
    if (!p.displayName) p.displayName = displayName;
    if (p.connected === false) p.connected = true;
    if (typeof p.questionStartAt !== "number") p.questionStartAt = now();
    return p;
  });

  const pSnap = await db.ref(`${path}/participants/${uid}/currentIndex`).get();
  const currentIndex = pSnap.exists() ? Number(pSnap.val()) : 0;
  return { ok: true, currentIndex };
});

export const submitOrgAsyncAnswer = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  const { orgId, quizId, optionIdx } = req.data as {
    orgId: string;
    quizId: string;
    optionIdx: number;
  };
  await assertMember(orgId, uid);

  const quizPath = `organizations/${orgId}/quizzes/${quizId}`;
  let finishedNow = false;

  await db.ref(quizPath).transaction((q: any) => {
    if (!q || q.type !== "org-async" || q.state !== "active") return q;

    const user = q.participants?.[uid!];
    if (!user || user.finished) return q;

    const idx = typeof user.currentIndex === "number" ? user.currentIndex : 0;
    const qArr = Object.values(q.questions || {}) as QuizQuestion[];
    qArr.sort((a: any, b: any) => Number(a.id) - Number(b.id));

    const question = qArr[idx];
    if (!question) return q;

    const nowTs = now();
    const elapsed = typeof user.questionStartAt === "number" ? nowTs - user.questionStartAt : 0;
    const correct = optionIdx === question.correctIndex;

    if (!q.participants[uid!].answers) q.participants[uid!].answers = {};
    q.participants[uid!].answers[idx] = { optionIdx, timeMs: elapsed, correct };

    if (correct) q.participants[uid!].score = (q.participants[uid!].score || 0) + 1;

    if (idx + 1 >= qArr.length) {
      q.participants[uid!].finished = true;
      q.participants[uid!].finishedAt = nowTs;
      delete q.participants[uid!].questionStartAt;
      finishedNow = true;
    } else {
      q.participants[uid!].currentIndex = idx + 1;
      q.participants[uid!].questionStartAt = nowTs;
    }

    return q;
  });

  // ðŸ” Update leaderboard for both partial and finished states
  await recomputeAndStoreOrgLeaderboard(orgId, quizId, uid!);

  return { ok: true, finishedNow };
});

export const getOrgAsyncLeaderboard = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  const { orgId, quizId } = req.data as { orgId: string; quizId: string };
  await assertMember(orgId, uid);

  const snap = await db.ref(`organizations/${orgId}/orgAsyncLeaderboards/${quizId}`).get();
  const items = (snap.val() as any[]) || [];
  return { items };
});

/** Get my detailed attempt for a given org quiz (for review) */
export const getMyOrgAsyncAttempt = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  const { orgId, quizId } = req.data as { orgId: string; quizId: string };
  await assertMember(orgId, uid);

  const pSnap = await db.ref(`organizations/${orgId}/quizzes/${quizId}/participants/${uid}`).get();
  if (!pSnap.exists()) return { attempt: null };

  const p = pSnap.val();
  const answers = p?.answers ? (Object.values(p.answers) as any[]) : [];
  const { avgTimeMs, correctCount } = computeAttemptStats(answers);
  return {
    attempt: {
      uid,
      displayName: p?.displayName ?? uid,
      score: p?.score ?? 0,
      finished: !!p?.finished,
      finishedAt: p?.finishedAt ?? null,
      answers,
      stats: { avgTimeMs, correctCount },
    },
  };
});

/** List my org attempts (light) for quizzes of a given note */
export const listMyOrgAsyncAttempts = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  const { orgId, noteId } = req.data as { orgId: string; noteId: string };
  await assertMember(orgId, uid);

  const idxSnap = await db.ref(`organizations/${orgId}/orgAsyncQuizzes/${noteId}`).get();
  const idx = idxSnap.val() || {};
  const quizIds: string[] = Object.keys(idx);

  const attempts: any[] = [];
  for (const qid of quizIds) {
    const pSnap = await db.ref(`organizations/${orgId}/quizzes/${qid}/participants/${uid}`).get();
    if (pSnap.exists()) {
      const p = pSnap.val();
      attempts.push({
        quizId: qid,
        finished: !!p?.finished,
        finishedAt: p?.finishedAt ?? null,
        score: p?.score ?? 0,
      });
    }
  }
  attempts.sort((a, b) => (b.finishedAt ?? 0) - (a.finishedAt ?? 0));
  return { attempts };
});

/* --------------------------- PERSONAL-ASYNC APIs -------------------------- */

export const startOrResumePersonalAsyncAttempt = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  if (!uid) throw new HttpsError("unauthenticated", "Login required");

  const { quizId } = req.data as { quizId: string };
  const path = `users/${uid}/quizzes/${quizId}`;
  const snap = await db.ref(path).get(); // (minor) was db.ref(path)
  if (!snap.exists()) throw new HttpsError("not-found", "Quiz not found");

  const quiz = snap.val() as Quiz;
  if (quiz.type !== "personal-async") throw new HttpsError("failed-precondition", "Not a personal quiz");

  await db.ref(`${path}/participants/${uid}`).transaction((p: any) => {
    if (!p) {
      return {
        joinedAt: now(),
        displayName: "You",
        connected: true,
        score: 0,
        currentIndex: 0,
      };
    }
    if (p.connected === false) p.connected = true;
    return p;
  });

  const cur = await db.ref(`${path}/participants/${uid}/currentIndex`).get();
  return { ok: true, currentIndex: cur.exists() ? Number(cur.val()) : 0 };
});

export const submitPersonalAsyncAnswer = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  if (!uid) throw new HttpsError("unauthenticated", "Login required");

  const { quizId, optionIdx } = req.data as { quizId: string; optionIdx: number };
  const quizPath = `users/${uid}/quizzes/${quizId}`;
  let finishedNow = false;

  await db.ref(quizPath).transaction((q: any) => {
    if (!q || q.type !== "personal-async" || q.state !== "active") return q;

    const user = q.participants?.[uid!];
    if (!user || user.finished) return q;

    const idx = typeof user.currentIndex === "number" ? user.currentIndex : 0;
    const qArr = Object.values(q.questions || {}) as QuizQuestion[];
    qArr.sort((a: any, b: any) => Number(a.id) - Number(b.id));
    const total = qArr.length;

    const question = qArr[idx];
    if (!question) return q;

    const nowTs = now();
    const elapsed = typeof user.questionStartAt === "number" ? nowTs - user.questionStartAt : 0;

    const correct = optionIdx === question.correctIndex;

    if (!q.participants[uid!].answers) q.participants[uid!].answers = {};
    q.participants[uid!].answers[idx] = { optionIdx, timeMs: elapsed, correct };

    if (correct) q.participants[uid!].score = (q.participants[uid!].score || 0) + 1;

    if (idx + 1 >= total) {
      q.participants[uid!].finished = true;
      q.participants[uid!].finishedAt = nowTs;
      delete q.participants[uid!].questionStartAt;
      finishedNow = true;
    } else {
      q.participants[uid!].currentIndex = idx + 1;
      q.participants[uid!].questionStartAt = nowTs;
    }

    return q;
  });

  return { ok: true, finishedNow };
});

/* ------------------------------ EXTRA: detail ----------------------------- */
/** Minimal quiz detail (with questions) for client attempt/review UIs */
export const getOrgQuizDetail = onCall(async (req) => {
  const uid = req.auth?.uid as string | undefined;
  const { orgId, quizId } = req.data as { orgId: string; quizId: string };
  await assertMember(orgId, uid);

  const snap = await db.ref(`organizations/${orgId}/quizzes/${quizId}`).get();
  if (!snap.exists()) throw new HttpsError("not-found", "Quiz not found");
  const q = snap.val() as Quiz;
  if (q.type !== "org-async") throw new HttpsError("failed-precondition", "Not an org-async quiz");

  const questions = q.questions || {};
  const numQuestions = Object.keys(questions).length;

  const payload = {
    id: q.id,
    title: (q as any).title ?? "Anytime Quiz",
    numQuestions,
    questionDurationSec: q.questionDurationSec ?? 45,
    questions,
  };

  return { quiz: payload };
});
